var pageScript = "// @ts-check\r\n\r\n/**\r\n * Make a function chainable.\r\n * @param {function} fn The function.\r\n * @param {Record<string, function>} methods The methods that can be chained to\r\n * the function. Each entry in `methods` should actually be a method factory.\r\n * @returns\r\n */\r\nconst chainable = (fn, methods) => {\r\n  // Clone the function so we don't mutate the original.\r\n  fn = fn.bind({});\r\n\r\n  // Add methods that can be chained to the function. Each method gets a\r\n  // reference to the function so it can call it and work with it's return\r\n  // value.\r\n  Object.entries(methods).forEach(([name, factory]) => (fn[name] = factory(fn)));\r\n\r\n  return fn\r\n};\n\n// @ts-check\r\n\r\n/**\r\n * Expose variables to global window object.\r\n * @param {object} obj\r\n * @returns\r\n */\r\nconst exposeToWindow = obj =>\r\n  Object.entries(obj).forEach(([key, value]) => (window[key] = value));\n\n// @ts-check\r\n\r\n/**\r\n * Get the note number for the specified note name.\r\n * @example getNoteNumber('C3') // -> 60 (Note: uses C3 as middle C!)\r\n * @param {string|number} note\r\n * @returns {number}\r\n */\r\nconst getNoteNumber = note => {\r\n  if (typeof note !== 'string') return note\r\n\r\n  const name = note.slice(0, -1).toLowerCase();\r\n  const octave = parseInt(note.slice(-1));\r\n\r\n  // prettier-ignore\r\n  const offsets = {\r\n    'c': 0, 'c#': 1, 'db': 1, 'd': 2, 'd#': 3, 'eb': 3,\r\n    'e': 4, 'f': 5, 'f#': 6, 'gb': 6, 'g': 7, 'g#': 8,\r\n    'ab': 8, 'a': 9, 'a#': 10, 'bb': 10, 'b': 11\r\n  };\r\n\r\n  return offsets[name.toLowerCase()] + (octave + 2) * 12\r\n};\n\n// @ts-check\r\n\r\n/**\r\n * @param {number} value\r\n * @param {number} from\r\n * @param {number} to\r\n */\r\nconst linearRamp = (value, from, to) => value * (to - from) + from;\n\n// @ts-check\r\n\r\n/**\r\n * Map a value to another range.\r\n * @param {number} value\r\n * @param {number} inMin\r\n * @param {number} inMax\r\n * @param {number} outMin\r\n * @param {number} outMax\r\n * @returns\r\n */\r\nconst map = (value, inMin, inMax, outMin, outMax) =>\r\n  ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;\n\nvar state = {\r\n  /** @type {Record<string, number>} */\r\n  ccValues: {},\r\n\r\n  /** @type {Set<string>} */\r\n  playingNotes: new Set(),\r\n\r\n  initialDefaults: {\r\n    channel: 0,\r\n    input: 0,\r\n    adsr: [100, 100, 1, 100]\r\n  },\r\n\r\n  defaults: {\r\n    channel: 0,\r\n    input: 0,\r\n    adsr: [100, 100, 1, 100]\r\n  }\r\n};\n\n// @ts-check\r\n\r\nclass Envelope {\r\n  active = false\r\n  noteOn = false\r\n  /** @type {number|null} */\r\n  gateDuration = null\r\n  /** @type {number|null} */\r\n  startTime = null\r\n\r\n  constructor({ a, d, s, r }) {\r\n    this.a = a;\r\n    this.d = d;\r\n    this.s = s;\r\n    this.r = r;\r\n  }\r\n\r\n  trigger() {\r\n    this.startTime = null;\r\n    this.gateDuration = null;\r\n    this.noteOn = true;\r\n    this.active = true;\r\n  }\r\n\r\n  stop() {\r\n    this.noteOn = false;\r\n  }\r\n\r\n  /**\r\n   * @param {number} time\r\n   * @returns {number}\r\n   */\r\n  value(time) {\r\n    if (!this.active) return 0\r\n\r\n    this.startTime ??= time;\r\n    const elapsedTime = time - this.startTime;\r\n    const { a, d, s, r } = this;\r\n\r\n    if (elapsedTime < a) {\r\n      // Attack\r\n      const factor = elapsedTime / a;\r\n      return linearRamp(factor, 0, 1)\r\n    } else if (elapsedTime < a + d && s > 0) {\r\n      // Decay (only if there is sustain)\r\n      const factor = (elapsedTime - a) / d;\r\n      return linearRamp(factor, 1, s)\r\n    } else if (this.noteOn && s > 0) {\r\n      // Sustain (if the note is still on and there is sustain)\r\n      return s\r\n    } else {\r\n      // Release\r\n      this.gateDuration ??= elapsedTime;\r\n      const factor = Math.min(1, (elapsedTime - this.gateDuration) / r);\r\n\r\n      // Envelope has finished.\r\n      if (factor === 1) this.active = false;\r\n\r\n      // If there was no sustain, there also was no decay so we can start the\r\n      // release at 1.0\r\n      const from = s || 1;\r\n      return linearRamp(factor, from, 0)\r\n    }\r\n  }\r\n}\n\n// @ts-check\r\n\r\n/**\r\n * Generate a new transform that allows to modify the previous value in the\r\n * function chain.\r\n * @param {function} fn The previous function\r\n */\r\nconst value = fn => modify =>\r\n  chainable((...args) => modify(fn(...args)), { scale, range });\n\n// @ts-check\r\n\r\n/**\r\n * Generate a new transform that maps the previous value in the function chain\r\n * to a new range.\r\n * @param {function} fn The previous function\r\n */\r\nconst range = fn => (min = 0, max = 1) =>\r\n  chainable((...args) => map(fn(...args), 0, 1, min, max), { scale, value });\n\n// @ts-check\r\n\r\n/**\r\n * Generate a new transform that scales the previous value in the function\r\n * chain.\r\n * @param {function} fn The previous function\r\n */\r\nconst scale = fn => factor =>\r\n  chainable((...args) => fn(...args) * factor, { range, value });\n\n// @ts-check\r\n\r\nconst envelopes = {};\r\n\r\n/**\r\n * Adsr is chainable to `note()`. It creates an envelope and returns a chainable\r\n * function, which in turn returns the envelope value at a given time.\r\n * @param {string} noteId\r\n */\r\nconst adsr = noteId => () => (a, d, s, r) => {\r\n[a, d, s, r] = [a, d, s, r].map(\r\n    (arg, i) => arg ?? state.defaults.adsr[i] ?? state.initialDefaults.adsr[i]\r\n  );\r\n\r\n  envelopes[noteId] = new Envelope({ a, d, s, r });\r\n  const envelope = envelopes[noteId];\r\n\r\n  return chainable(({ time }) => envelope.value(time * 1000), {\r\n    scale,\r\n    range,\r\n    value\r\n  })\r\n};\n\n// @ts-check\r\n\r\nclass SimpleEventEmitter {\r\n  /** @type {Record<any, function[]>} */\r\n  listeners = {}\r\n\r\n  /**\r\n   * Add a new event handler.\r\n   * @param {any} type\r\n   * @param {function} handler\r\n   */\r\n  on(type, handler) {\r\n    this.listeners[type] ??= [];\r\n    this.listeners[type].push(handler);\r\n  }\r\n\r\n  /**\r\n   * Remove an event handler.\r\n   * @param {any} type\r\n   * @param {function} handler\r\n   */\r\n  off(type, handler) {\r\n    this.listeners[type]?.splice(this.listeners[type].indexOf(handler), 1);\r\n  }\r\n\r\n  /**\r\n   * Emit an event.\r\n   * @param {any} type\r\n   * @param {any} payload\r\n   */\r\n  emit(type, payload) {\r\n    this.listeners[type]?.forEach(handler => handler(payload));\r\n  }\r\n}\n\n// @ts-check\r\n\r\n/**\r\n * A thin wrapper around Web Midi.\r\n */\r\nclass MidiAccess extends SimpleEventEmitter {\r\n  static TypeNoteOff = 0x80\r\n  static TypeNoteOn = 0x90\r\n  static TypeAfterTouchPoly = 0xa0\r\n  static TypeControlChange = 0xb0\r\n  static TypeProgramChange = 0xc0\r\n  static TypeAfterTouchChannel = 0xd0\r\n  static TypePitchBend = 0xe0\r\n  static TypeSystemExclusive = 0xf0\r\n  static TypeTimeCodeQuarterFrame = 0xf1\r\n  static TypeSongPosition = 0xf2\r\n  static TypeSongSelect = 0xf3\r\n  static TypeTuneRequest = 0xf6\r\n  static TypeClock = 0xf8\r\n  static TypeStart = 0xfa\r\n  static TypeContinue = 0xfb\r\n  static TypeStop = 0xfc\r\n  static TypeActiveSensing = 0xfe\r\n  static TypeSystemReset = 0xff\r\n\r\n  enabled = false\r\n  isSetup = false\r\n  /** @type {WebMidi.MIDIAccess} */\r\n  access = null\r\n\r\n  /**\r\n   * @param {WebMidi.MIDIMessageEvent} message\r\n   * @returns\r\n   */\r\n  static parseMessage(message) {\r\n    const [status, data1, data2] = message.data;\r\n    const type = status & 0xf0;\r\n    const channel = status & 0x0f;\r\n    return { type, channel, data: [data1, data2] }\r\n  }\r\n\r\n  async setup() {\r\n    this.access = await navigator.requestMIDIAccess();\r\n\r\n    for (const input of this.access.inputs.values()) {\r\n      input.open();\r\n    }\r\n    const handleMessage = this.handleMessage.bind(this);\r\n\r\n    this.access.addEventListener('statechange', ({ port }) => {\r\n      if (port.state === 'connected') {\r\n        const input = this.access.inputs.get(port.id);\r\n        input?.addEventListener('midimessage', handleMessage);\r\n      }\r\n    });\r\n    this.isSetup = true;\r\n  }\r\n\r\n  async start() {\r\n    if (!this.isSetup) await this.setup();\r\n    this.enabled = true;\r\n  }\r\n\r\n  pause() {\r\n    this.enabled = false;\r\n  }\r\n\r\n  getInputByIndex(index) {\r\n    return this.access && [...this.access.inputs.values()][index]\r\n  }\r\n\r\n  getInputByName(name) {\r\n    return (\r\n      this.access &&\r\n      [...this.access.inputs.values()].find(input => input.name === name)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Get a midi input's id by index or name.\r\n   * @param {number|string} indexOrName\r\n   * @returns {string}\r\n   */\r\n  getInputId(indexOrName) {\r\n    const input =\r\n      typeof indexOrName === 'number'\r\n        ? this.getInputByIndex(indexOrName)\r\n        : this.getInputByName(indexOrName);\r\n\r\n    return input?.id\r\n  }\r\n\r\n  handleMessage(message) {\r\n    if (this.enabled) {\r\n      const { type, data, channel } = MidiAccess.parseMessage(message);\r\n      this.emit(type, { data, channel, input: message.target });\r\n    }\r\n  }\r\n}\n\n// @ts-check\r\n\r\n/** @type {HTMLElement|null} */\r\nlet gui;\r\n/** @type {HTMLElement|null} */\r\nlet inputs;\r\n/** @type {HTMLElement|null} */\r\nlet messages;\r\n\r\nconst maxMessages = 10;\r\nlet isSetup = false;\r\nlet isEnabled = false;\r\n\r\nconst setup = () => {\r\n  gui = document.createElement('div');\r\n  gui.classList.add('hydra-midi-gui');\r\n  gui.innerHTML = `\r\n    <div class=\"hydra-midi-inputs\"></div>\r\n    <span>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</span>\r\n    <div class=\"hydra-midi-heading\">Ch Type Values</div>\r\n    <div class=\"hydra-midi-messages\">${[...Array(maxMessages)]\r\n      .map(() => `<div></div>`)\r\n      .join('')}</div>\r\n  `;\r\n\r\n  document.body.append(gui);\r\n  inputs = gui.querySelector('.hydra-midi-inputs');\r\n  messages = gui.querySelector('.hydra-midi-messages');\r\n\r\n  isSetup = true;\r\n  isEnabled = true;\r\n};\r\n\r\n/**\r\n * Show the gui and set it up if necessary.\r\n */\r\nconst show = () => {\r\n  if (!isSetup) setup();\r\n  gui.hidden = false;\r\n  isEnabled = true;\r\n};\r\n\r\n/**\r\n * Hide the gui.\r\n */\r\nconst hide = () => {\r\n  gui.hidden = true;\r\n  isEnabled = false;\r\n};\r\n\r\n/**\r\n * Render a list of all open midi inputs.\r\n * @param {WebMidi.MIDIInputMap} list\r\n */\r\nconst showInputs = list => {\r\n  if (!isEnabled) return\r\n\r\n  const getInputName = input => input.name ?? input.id ?? 'n/a';\r\n  const template = (input, index) =>\r\n    `<div class=\"hydra-midi-input\" style=\"color: var(--color-${input.id})\">` +\r\n    `#${index} ` +\r\n    `<span class=\"hydra-midi-input-name\">${getInputName(input)}</span>` +\r\n    `</div>`;\r\n\r\n  inputs.innerHTML = [...list.values()].map(template).join('');\r\n};\r\n\r\n/**\r\n * Log a midi message and highlight the corresponding input.\r\n * @param {{\r\n *  input: WebMidi.MIDIInput,\r\n *  channel: number,\r\n *  type: string,\r\n *  data: number[]\r\n * }} message\r\n */\r\nconst logMidiMessage = message => {\r\n  if (!isEnabled) return\r\n\r\n  const pad = (value, length = 3) => String(value).padEnd(length, ' ');\r\n\r\n  const { input } = message;\r\n  const channel = pad(message.channel, 2);\r\n  const type = pad(message.type, 4);\r\n  const data1 = pad(message.data[0]);\r\n  const data2 = message.data[1] ? pad(message.data[1]) : '';\r\n\r\n  messages.removeChild(messages.firstChild);\r\n  const el = document.createElement('div');\r\n  el.style.color = `var(--color-midi-${type})`;\r\n  el.innerHTML = [channel, type, data1, data2].join(' ');\r\n  messages.append(el);\r\n\r\n  highlightInput(input, message.type);\r\n};\r\n\r\nconst highlightTimeouts = {};\r\n/**\r\n * Let the input flash for a short moment in the color of the received midi\r\n * message.\r\n * @param {*} input\r\n * @param {*} type\r\n */\r\nconst highlightInput = (input, type) => {\r\n  clearTimeout(highlightTimeouts[input.id]);\r\n\r\n  const inputColorVariable = `--color-${input.id}`;\r\n  gui.style.setProperty(inputColorVariable, `var(--color-midi-${type})`);\r\n\r\n  highlightTimeouts[input.id] = setTimeout(() => {\r\n    gui.style.setProperty(inputColorVariable, null);\r\n  }, 100);\r\n};\n\n// @ts-check\r\n\r\n// Those properties will never change, only their content, so it's save to\r\n// destructure.\r\nconst { ccValues, playingNotes } = state;\r\n\r\n// Expose the `MidiAccess` instance because we need it in other files too.\r\nconst midiAccess = new MidiAccess();\r\n\r\n/**\r\n * Get an id for a midi message using an osc style address.\r\n * @example getMidiId(60, 0, 1) // -> '60/0/1'\r\n * @param {number|string} value\r\n * @param {number|string} channel\r\n * @param {number|string} input\r\n * @returns\r\n */\r\nconst getMidiId = (value, channel, input) => {\r\n  if (input !== undefined) {\r\n    return `${value}/${channel}/${input ?? midiAccess.getInputId(0)}`\r\n  }\r\n};\r\n\r\n/**\r\n * Get all possible wildcard combinations for a midi id ({@link getMidiId}).\r\n * If we have an id for a midi note like this: '60/0/1' we could use the\r\n * wildcard '60/0/*' (Note 60 on channel 0 on any input).\r\n * @param {number} value\r\n * @param {number} channel\r\n * @param {string} input\r\n * @returns\r\n */\r\nconst getMidiWildcards = (value, channel, input) => [\r\n  getMidiId('*', '*', '*'),\r\n  getMidiId(value, '*', '*'),\r\n  getMidiId('*', channel, '*'),\r\n  getMidiId('*', '*', input),\r\n  getMidiId(value, channel, '*'),\r\n  getMidiId('*', channel, input),\r\n  getMidiId(value, '*', input)\r\n];\r\n\r\nconst resolveInput = input =>\r\n  input === '*' ? '*' : midiAccess.getInputId(input);\r\n\r\nconst resolveNote = note => (note === '*' ? note : getNoteNumber(note));\r\n\r\n/**\r\n * For all received midi values we not only save the value for the exact midi id\r\n * (e.g.: ccValues['74/0/input-0'] = 127) but also all possible wildcards.\r\n * So for CC 74 this would be:\r\n * 74 / * / * (CC 74 on any channel and any input)\r\n * 74 / * / input-0 (CC 74 on any channel on input-0 )\r\n * ... and so on\r\n * This might seem a little verbose but this way we can easily poll for values\r\n * without having to do any additional logic.\r\n * Listening to CC 74 on channel 0 on any input in hydra: `cc(74, 0, '*')` will\r\n * internally just look up `ccValues['74/0/*']`, which is super fast.\r\n */\r\n\r\nmidiAccess.on(MidiAccess.TypeControlChange, ({ data, channel, input }) => {\r\n  const [index, value] = data;\r\n  const ccId = getMidiId(index, channel, input.id);\r\n  const normalizedValue = value / 127;\r\n\r\n  ccValues[ccId] = normalizedValue;\r\n  getMidiWildcards(index, channel, input.id).forEach(\r\n    wildcard => (ccValues[wildcard] = normalizedValue)\r\n  );\r\n\r\n  logMidiMessage({ input, type: 'cc', channel, data });\r\n});\r\n\r\nmidiAccess.on(MidiAccess.TypeNoteOn, ({ data, channel, input }) => {\r\n  const [note] = data;\r\n  const noteId = getMidiId(note, channel, input.id);\r\n  playingNotes.add(noteId);\r\n  envelopes[noteId]?.trigger();\r\n\r\n  getMidiWildcards(note, channel, input.id).forEach(wildcard => {\r\n    playingNotes.add(wildcard);\r\n    envelopes[wildcard]?.trigger();\r\n  });\r\n\r\n  logMidiMessage({ input, type: 'on', channel, data });\r\n});\r\n\r\nmidiAccess.on(MidiAccess.TypeNoteOff, ({ data, channel, input }) => {\r\n  const [note] = data;\r\n  const noteId = getMidiId(note, channel, input.id);\r\n  playingNotes.delete(noteId);\r\n  envelopes[noteId]?.stop();\r\n\r\n  getMidiWildcards(note, channel, input.id).forEach(wildcard => {\r\n    playingNotes.delete(wildcard);\r\n    envelopes[wildcard]?.stop();\r\n  });\r\n\r\n  logMidiMessage({ input, type: 'off', channel, data });\r\n});\r\n\r\nmidiAccess.on(MidiAccess.TypePitchBend, ({ input, data, channel }) => {\r\n  const value = ((data[1] << 7) + data[0] - 8192) / 8192;\r\n  const displayValue = +value.toFixed(2);\r\n  logMidiMessage({ input, type: 'bend', channel, data: [displayValue] });\r\n});\r\n\r\nmidiAccess.on(MidiAccess.TypeAfterTouchChannel, ({ input, data, channel }) => {\r\n  logMidiMessage({ input, type: 'aft', channel, data });\r\n});\r\n\r\nmidiAccess.on(MidiAccess.TypeAfterTouchPoly, ({ input, data, channel }) => {\r\n  logMidiMessage({ input, type: 'aft', channel, data });\r\n});\n\n// @ts-check\r\n\r\nconst noteIsPlaying = noteId => state.playingNotes.has(noteId);\r\n\r\nconst getNoteId = (note, channel, input) =>\r\n  getMidiId(\r\n    resolveNote(note),\r\n    channel ?? state.defaults.channel,\r\n    resolveInput(input ?? state.defaults.input)\r\n  );\r\n\r\n/**\r\n * returns 1 if the specified note is playing, and 0 otherwise. This is useful\r\n * if you want to use the value inside a parameter function. See also {@link note}.\r\n * @example solid(1, 0, () => _note(60) * 0.5).out() // Could also be achieved with solid(1, 0, note(60).value(v => v * 0.5)).out()\r\n * @param {number|string} note\r\n * @param {number|string} channel\r\n * @param {number|string} input\r\n * @returns\r\n */\r\nconst _note = (note, channel, input) =>\r\n  noteIsPlaying(getNoteId(note, channel, input)) ? 1 : 0;\r\n\r\n/**\r\n * Create a chainable function that returns 1 if the specified note is playing,\r\n * and 0 otherwise.\r\n * @example osc().invert(note(60)).out()\r\n * @param {number|string} note A note number or a name like 'C3' or '*' to listen\r\n * to any note.\r\n * @param {number|string} channel\r\n * @param {number|string} input\r\n */\r\nconst note = (note, channel, input) => {\r\n  const noteId = getNoteId(note, channel, input);\r\n  const fn = () => (noteIsPlaying(noteId) ? 1 : 0);\r\n  return chainable(fn, { scale, range, value, adsr: adsr(noteId) })\r\n};\n\n// @ts-check\r\n\r\n/**\r\n * Channel is chainable to `midi` and `input()` and provides a channel for all\r\n * the functions that are chained to it.\r\n * @example osc(midi.channel(4).note(60)).out()\r\n * @example osc(midi.input('my keyboard').channel('*').note(60)).out()\r\n * @param {number|string} channel\r\n * @param {number|string} input\r\n * @returns\r\n */\r\nconst channel = (channel, input = null) => ({\r\n  note: (_note, _channel, _input) =>\r\n    note(_note, _channel ?? channel, _input ?? input),\r\n\r\n  cc: (_index, _channel, _input) =>\r\n    cc(_index, _channel ?? channel, _input ?? input)\r\n});\n\n// @ts-check\r\n\r\n/**\r\n * Input is chainable only to `midi` and provides an input for all the functions\r\n * that are chained to it.\r\n * @example osc(midi.input(3).cc(74)).out()\r\n * @example osc(midi.input('*').channel(15).cc(74)).out()\r\n * @param {number|string} input\r\n * @returns\r\n */\r\nconst input = input => ({\r\n  note: (_note, _channel, _input) => note(_note, _channel, _input ?? input),\r\n  cc: (_index, _channel, _input) => cc(_index, _channel, _input ?? input),\r\n  channel: _channel => channel(_channel, input)\r\n});\n\n// @ts-check\r\n\r\nconst getCcId = (index, channel, input) =>\r\n  getMidiId(\r\n    index,\r\n    channel ?? state.defaults.channel,\r\n    resolveInput(input ?? state.defaults.input)\r\n  );\r\n\r\n/**\r\n * Return a CC value. This is useful if you want to use the value inside a\r\n * parameter function. See also {@link _cc}.\r\n * @example osc(() => _cc(74) / 2).out() // Could also be achieved with osc(cc(74).value(v => v / 2)).out()\r\n * @param {number|string} index\r\n * @param {number|string} channel\r\n * @param {number|string} input\r\n * @returns\r\n */\r\nconst _cc = (index, channel, input) =>\r\n  state.ccValues[getCcId(index, channel, input)] ?? 0;\r\n\r\n/**\r\n * Generate a chainable function that returns the value for the specified CC\r\n * index.\r\n * @example osc(cc(74)).out() // CC 74 will modulate the osc in realtime.\r\n * @param {number|string} index A CC index or '*' for any CC.\r\n * @param {number|string} channel A channel or '*' for any channel.\r\n * @param {number|string} input An input index or an input name or '*' for any\r\n * input.\r\n * @returns\r\n */\r\nconst cc = (index, channel, input) => {\r\n  const ccId = getCcId(index, channel, input);\r\n  const fn = () => state.ccValues[ccId] ?? 0;\r\n  return chainable(fn, { scale, range, value })\r\n};\n\n// @ts-check\r\n\r\nconst start = defaults => {\r\n  state.defaults = { ...state.initialDefaults, ...defaults };\r\n\r\n  midiAccess\r\n    .start()\r\n    .then(() =>\r\n      midiAccess.access.addEventListener('statechange', () =>\r\n        showInputs(midiAccess.access.inputs)\r\n      )\r\n    );\r\n\r\n  // Allow `midi.start().show()` chaining.\r\n  return { show }\r\n};\r\n\r\nconst pause = () => midiAccess.pause();\r\n\r\nconst midi = { start, pause, show, hide, input, channel };\n\n// @ts-check\r\n\r\nexposeToWindow({ midi, cc, _cc, note, _note });\n";

// The page script is bundled by rollup (see `rollup.config.js`) and treated as

// The page script has to run in the same context as the hydra website so we can
// manipulate the global window object. But chrome extensions do not seem to
// have permission to load a script from file so we inject the script directly.
const script = document.createElement('script');
script.text = pageScript;
script.setAttribute('type', 'module');
document.head.prepend(script);
