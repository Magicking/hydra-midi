// @ts-check

/**
 * Make a function chainable.
 * @param {function} fn The function.
 * @param {Record<string, function>} methods The methods that can be chained to
 * the function. Each entry in `methods` should actually be a method factory.
 * @returns
 */
const chainable = (fn, methods) => {
  // Clone the function so we don't mutate the original.
  fn = fn.bind({});

  // Add methods that can be chained to the function. Each method gets a
  // reference to the function so it can call it and work with it's return
  // value.
  Object.entries(methods).forEach(([name, factory]) => (fn[name] = factory(fn)));

  return fn
};

// @ts-check

/**
 * Expose variables to global window object.
 * @param {object} obj
 * @returns
 */
const exposeToWindow = obj =>
  Object.entries(obj).forEach(([key, value]) => (window[key] = value));

// @ts-check

/**
 * Get the note number for the specified note name.
 * @example getNoteNumber('C3') // -> 60 (Note: uses C3 as middle C!)
 * @param {string|number} note
 * @returns
 */
const getNoteNumber = note => {
  if (typeof note === 'number') return note

  const name = note.slice(0, -1).toLowerCase();
  const octave = parseInt(note.slice(-1));

  // prettier-ignore
  const offsets = {
    'c': 0, 'c#': 1, 'db': 1, 'd': 2, 'd#': 3, 'eb': 3,
    'e': 4, 'f': 5, 'f#': 6, 'gb': 6, 'g': 7, 'g#': 8,
    'ab': 8, 'a': 9, 'a#': 10, 'bb': 10, 'b': 11
  };

  return offsets[name.toLowerCase()] + (octave + 2) * 12
};

// @ts-check

/**
 *
 * @param {number} value
 * @param {number} from
 * @param {number} to
 */
const linearRamp = (value, from, to) => value * (to - from) + from;

// @ts-check

/**
 * Map a value to another range.
 * @param {number} value
 * @param {number} inMin
 * @param {number} inMax
 * @param {number} outMin
 * @param {number} outMax
 * @returns
 */
const map = (value, inMin, inMax, outMin, outMax) =>
  ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;

const midiTypes = {
  NoteOff: 0x80,
  NoteOn: 0x90,
  AfterTouchPoly: 0xa0,
  ControlChange: 0xb0,
  ProgramChange: 0xc0,
  AfterTouchChannel: 0xd0,
  PitchBend: 0xe0,
  SystemExclusive: 0xf0,
  TimeCodeQuarterFrame: 0xf1,
  SongPosition: 0xf2,
  SongSelect: 0xf3,
  TuneRequest: 0xf6,
  Clock: 0xf8,
  Start: 0xfa,
  Continue: 0xfb,
  Stop: 0xfc,
  ActiveSensing: 0xfe,
  SystemReset: 0xff
};

const parseMidi = message => {
  const [status, data1, data2] = message.data;
  const type = status & 0xf0;
  const channel = status & 0x0f;
  return { type, channel, data: [data1, data2] }
};

const scale = fn => factor => (...args) => fn(...args) * factor;

const range = fn => (min = 0, max = 1) => (...args) =>
  map(fn(...args), 0, 1, min, max);

// @ts-check

class Envelope {
  constructor({ a, d, s, r }) {
    this.a = a;
    this.d = d;
    this.s = s;
    this.r = r;

    this.noteOn = true;
    this.gateDuration = null;
    this.startTime = null;
  }

  trigger() {
    this.startTime = null;
  }

  /**
   * @param {number} time
   * @returns {number}
   */
  value(time) {
    this.startTime ??= time;
    const elapsedTime = time - this.startTime;
    const { a, d, s, r } = this;

    if (elapsedTime < a) {
      // Attack
      const factor = elapsedTime / a;
      return linearRamp(factor, 0, 1)
    } else if (elapsedTime < a + d && s > 0) {
      // Decay (only if there is sustain)
      const factor = (elapsedTime - a) / d;
      return linearRamp(factor, 1, s)
    } else if (this.noteOn && s > 0) {
      // Sustain (if the note is still on and there is sustain)
      return s
    } else {
      // Release
      this.gateDuration ??= elapsedTime;
      const factor = Math.min(1, (elapsedTime - this.gateDuration) / r);
      // If there was no sustain, there also was no decay so we can start the
      // release at 1.0
      const from = s || 1;
      return linearRamp(factor, from, 0)
    }
  }
}

const envelopes = {};

/**
 * Adsr is chainable to `note()`. It creates an envelope and returns a chainable
 * function that returns the envelope value at a given time.
 * @param {*} note
 * @returns
 */
const adsr = note => fn => (a = 100, d = 100, s = 1, r = 100) => {
  envelopes[note] ??= new Envelope({ a, d, s, r });
  const envelope = envelopes[note];

  return chainable(({ time }) => envelope.value(time * 1000), { scale, range })
};

// @ts-check

/** @type {number[]} */
const ccValues = Array(128).fill(0.5);

/** @param {number} index */
const _cc = index => ccValues[index];

/** @param {number} index */
const cc = index => chainable(_cc, [index]);

// @ts-check

const noteValues = {};

/** @param {string|number} note */
const _note = note => (noteValues[getNoteNumber(note)] ? 1 : 0);

/** @param {string|number} note */
const note = note => {
  note = getNoteNumber(note);
  return chainable(() => _note(note), { scale, range, adsr: adsr(note) })
};

const access = await navigator.requestMIDIAccess();

for (const input of access.inputs.values()) {
  input.onmidimessage = message => {
    const { type, data, channel } = parseMidi(message);
    if (type === midiTypes.ControlChange) {
      ccValues[data[0]] = (data[1] + 1) / 128;
    } else if (type === midiTypes.NoteOn) {
      noteValues[data[0]] = true;
    } else if (type === midiTypes.NoteOff) {
      delete noteValues[data[0]];
    }
  };
}

// Hydra's logging is quite verbose.
// setTimeout(console.clear, 2000)

exposeToWindow({ cc, _cc, note, _note });
