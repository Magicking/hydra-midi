const chainable = (fn, args, methods) => {
  const result = () => fn(...args);
  Object.entries(methods).forEach(
    ([name, factory]) => (result[name] = factory(result))
  );
  return result
};

// @ts-check

/**
 * Expose variables to global window object.
 * @param {object} obj
 * @returns
 */
const exposeToWindow = obj =>
  Object.entries(obj).forEach(([key, value]) => (window[key] = value));

// @ts-check

/**
 * Get the note number for the specified note name.
 * @example getNoteNumber('C3') // -> 60 (Note: uses C3 as middle C!)
 * @param {string|number} note
 * @returns
 */
const getNoteNumber = note => {
  if (typeof note === 'number') return note

  const name = note.slice(0, -1).toLowerCase();
  const octave = parseInt(note.slice(-1));

  // prettier-ignore
  const offsets = {
    'c': 0, 'c#': 1, 'db': 1, 'd': 2, 'd#': 3, 'eb': 3,
    'e': 4, 'f': 5, 'f#': 6, 'gb': 6, 'g': 7, 'g#': 8,
    'ab': 8, 'a': 9, 'a#': 10, 'bb': 10, 'b': 11
  };

  return offsets[name.toLowerCase()] + (octave + 2) * 12
};

// @ts-check

/**
 * Map a value to another range.
 * @param {number} value
 * @param {number} inMin
 * @param {number} inMax
 * @param {number} outMin
 * @param {number} outMax
 * @returns
 */
const map = (value, inMin, inMax, outMin, outMax) =>
  ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;

const midiTypes = {
  NoteOff: 0x80,
  NoteOn: 0x90,
  AfterTouchPoly: 0xa0,
  ControlChange: 0xb0,
  ProgramChange: 0xc0,
  AfterTouchChannel: 0xd0,
  PitchBend: 0xe0,
  SystemExclusive: 0xf0,
  TimeCodeQuarterFrame: 0xf1,
  SongPosition: 0xf2,
  SongSelect: 0xf3,
  TuneRequest: 0xf6,
  Clock: 0xf8,
  Start: 0xfa,
  Continue: 0xfb,
  Stop: 0xfc,
  ActiveSensing: 0xfe,
  SystemReset: 0xff
};

const parseMidi = message => {
  const [status, data1, data2] = message.data;
  const type = status & 0xf0;
  const channel = status & 0x0f;
  return { type, channel, data: [data1, data2] }
};

const scale = value => factor => () => value() * factor;

const range = value => (min = 0, max = 1) => () =>
  map(value(), 0, 1, min, max);

const ccValues = Array(128).fill(0.5);

const _cc = index => ccValues[index];

const cc = index => chainable(_cc, [index], { scale, range });

// @ts-check

const noteValues = {};

const _note = note => (noteValues[getNoteNumber(note)] ? 1 : 0);

const note = note => {
  const number = getNoteNumber(note);
  return chainable(_note, [number], { scale, range })
};

const access = await navigator.requestMIDIAccess();
for (const input of access.inputs.values()) {
  input.onmidimessage = message => {
    const { type, data, channel } = parseMidi(message);
    if (type === midiTypes.ControlChange) {
      ccValues[data[0]] = (data[1] + 1) / 128;
    } else if (type === midiTypes.NoteOn) {
      noteValues[data[0]] = true;
    } else if (type === midiTypes.NoteOff) {
      delete noteValues[data[0]];
    }
  };
}

exposeToWindow({ cc, _cc, note, _note });
